Руководство и задания к 3-ей практике

### 1. Работа с вложенными маршрутами

Ранее мы писали все маршруты в корневом файле `urls.py`, что может быть достаточно неудобно, особенно когда маршрутов будет много приложений, когда 
каждое приложение внутри себя обрабатывает несколько маршрутов. Пример приложение `store` от него в `urls.py` уже используется
2 маршрута (`'product/'` и `''`).

На практике можно в корневом `urls.py` прописывать только файл с маршрутами приложения, а Django уже сам подтянет
маршруты из приложения, так структура становится более читаемая.

Для этого создадим файл `urls.py` в приложении `store`, где пропишем маршруты скопированные из корневого `urls.py` (в папке `project`).
Маршруты располагаются во всё той же переменной `urlpatterns` - это зарезервированная переменная в Django, в которой предполагается 
хранение маршрутов обработки представлений. 

```python
# urls.py in store

from django.urls import path
from .views import products_view, shop_view

urlpatterns = [
    path('product/', products_view),
    path('', shop_view),
]
```

Далее в корневом `urls.py` необходимо поправить прошлые маршруты, для это воспользуемся функцией `include`
позволяющая указать приложение, а Django самостоятельно возьмёт маршруты из переменной `urlpatterns` приложения.

Вот как трансформируются маршруты приложения `store` в корневом `urls.py`

```python
path('', include('store.urls')),
```
А корневой `urls.py` будет выглядеть так

![img.png](img.png)

Теперь ссылки, что были доступны ранее для приложения `store` также доступны.

#### Самостоятельно

Самостоятельно перепишите маршрут с использованием `include` для приложения `app_weather`,
но сделайте так, чтобы тот маршрут, по которому ранее обрабатывался прогноз погоды - также обрабатывался.

Допустим если до использования `include` - прогноз погоды был доступен по адресу http://127.0.0.1:8000/weather/ ,
то после использования `include` - адрес доступа сохранился.


### 2. Работа с параметрами запроса

Ранее в приложении прогноза погоды, мы не могли изменить координату через адресную строку,
приходилось менять это значение в коде, теперь давайте сделаем код более гибким и будем брать
значения координат для прогноза погоды из прааметров GET запроса.

Получить данные из запроса, можно из переменной `request` вашей функции представления. Для этого обратитесь к переменной
`GET` объекта `request` (`request.GET`), в котором будет `словарь`, где ключи словаря - переменные в запросе, значения - значения 
переменных в запросе.

Допустим при обработке запроса `https://example.ru?q=запрос&a=ответ` из `request.GET` 
получим словарь `{'q': 'запрос', 'a': 'ответ'}`, который можно использовать для своих нужд.

Тогда код представления для прогноза погоды будет следующим.

```python
from django.http import JsonResponse
from weather_api import current_weather


def weather_view(request):
    if request.method == "GET":
        lat = request.GET.get('lat')  # данные придут в виде строки
        lon = request.GET.get('lon')  # данные придут в виде строки
        if lat and lon:
            data = current_weather(lat=lat, lon=lon)
        else:
            data = current_weather(59.93, 30.31)
        return JsonResponse(data, json_dumps_params={'ensure_ascii': False,
                                                     'indent': 4})
```

И теперь к сервер берет данные из строки запроса и работает с ними. Допустим так
можем узнать погоду в Москве http://127.0.0.1:8000/weather?lat=55.75&lon=37.61 

А если ничего не передать, то погоду будет в Санкт-Петербурге http://127.0.0.1:8000/weather .

#### Самостоятельно

Доработайте представление `products_view` приложения `store` так, чтобы через параметры запроса `id` 
представление реализовывало следующий функционал:
* Если `id` было передано в запросе и такой ключ существует в `DATABASE`, то представление возвращает характеристики товара
* Если `id` было передано в запросе и такого ключа НЕ существует в `DATABASE`, то представление возвращает 
`HttpResponseNotFound("Данного продукта нет в базе данных")`
* Если `id` НЕ было передано в запросе, то возвращает все товары.

Пример файла `view.py` приложения `store` 

```python
from django.http import JsonResponse, HttpResponse, HttpResponseNotFound
from .models import DATABASE


def products_view(request):
    if request.method == "GET":
        # Ваша реализация
```

Проверьте, что ваше представление отрабатывает все случаи:

* 'Нет продукта' - http://127.0.0.1:8000/product/?id=0

* 'Один продукт' - http://127.0.0.1:8000/product/?id=3

* 'Все продукты' - http://127.0.0.1:8000/product/

### 3. Работа с параметрами запроса через обработчик маршрутов Django

